<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5Base Field - 3D Interactive Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .legend-item { display: flex; align-items: center; margin-bottom: 0.5rem; }
        .legend-color { width: 20px; height: 20px; margin-right: 0.5rem; border: 1px solid #333; }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div class="relative h-screen w-screen">
        <!-- 3D Canvas -->
        <div id="canvas-container" class="absolute inset-0"></div>
        
        <!-- UI Overlay -->
        <div class="absolute top-0 left-0 p-4 bg-black bg-opacity-50 rounded-br-lg">
            <h1 class="text-2xl font-bold mb-2">5Base Field</h1>
            <p class="text-sm mb-4">Interactive 3D Visualization</p>
            
            <!-- Controls -->
            <div class="mb-4">
                <button id="reset-camera" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded mr-2">
                    Reset View
                </button>
                <button id="toggle-legend" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded">
                    Toggle Legend
                </button>
            </div>
            
            <!-- Legend -->
            <div id="legend" class="text-xs bg-black bg-opacity-75 p-2 rounded">
                <h2 class="font-bold mb-2">Legend</h2>
                <div class="legend-item">
                    <div class="legend-color bg-gray-500"></div>
                    <span>Infield (13m × 13m)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-yellow-500"></div>
                    <span>Fair Territory (18m × 18m)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-white"></div>
                    <span>Foul Territory</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-red-500"></div>
                    <span>No-Hit Zone</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-yellow-300"></div>
                    <span>Batter's Box (3m × 3m)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-white border-2 border-black"></div>
                    <span>Bases (50cm × 50cm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-orange-500"></div>
                    <span>Safe Area (1.5m)</span>
                </div>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="absolute bottom-0 right-0 p-4 bg-black bg-opacity-50 rounded-tl-lg text-xs">
            <p><strong>Controls:</strong> Left-click + drag to rotate | Right-click + drag to pan | Scroll to zoom</p>
        </div>
    </div>

    <!-- Import Three.js using ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        // Import Three.js and OrbitControls
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Main Three.js setup
        let scene, camera, renderer, controls;
        
        // Field dimensions in meters
        const INFIELD_SIZE = 13; // 13m square infield
        const FAIR_TERRITORY_SIZE = 18; // 18m square fair territory
        const BASE_SIZE = 0.6; // 50cm square bases
        const RUNNERS_BASE_SIZE = 1.5; // 50cm square bases
        const BATTERS_BOX_SIZE = 2.5; // 3m square batter's box
        const SAFE_AREA_WIDTH = 1.5; // 1.5m safe area at first base
        const NO_HIT_DISTANCE = 4.5; // 4.5m from home along foul lines
        const FENCE_HEIGHT = 1; // 1m high fences
        
        // Colors
        const INFIELD_COLOR = 0x808080; // Gray
        const FAIR_TERRITORY_COLOR = 0xFFD700; // Yellow
        const FOUL_TERRITORY_COLOR = 0xFFFFFF; // White
        const NO_HIT_ZONE_COLOR = 0xFF6347; // Tomato red
        const BATTERS_BOX_COLOR = 0xF0E68C; // Khaki
        const BASE_COLOR = 0xFFFFFF; // White
        const SAFE_AREA_COLOR = 0xFFA500; // Orange
        const FENCE_COLOR = 0x2F4F4F; // Dark slate gray
        const LINE_COLOR = 0x000000; // Black
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(
                60, // Field of view
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1, // Near clipping plane
                1000 // Far clipping plane
            );
            camera.position.set(0, 10, 20); // Position camera above and behind home plate
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2.1; // Limit to just above horizontal
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.6);
            scene.add(ambientLight);
            
            // Add directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Create the field
            createField();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Add button event listeners
            document.getElementById('reset-camera').addEventListener('click', resetCamera);
            document.getElementById('toggle-legend').addEventListener('click', toggleLegend);
            
            // Start animation loop
            animate();
        }
        
        // Create the baseball field
        function createField() {
            // Calculate positions
            // Center the field at the origin
            // Home plate is at the bottom-right corner of the infield
            const homePos = new THREE.Vector3(INFIELD_SIZE/2, 0, -INFIELD_SIZE/2);
            
            // First base is at the top-right corner of the infield
            const firstBaseCorner = new THREE.Vector3(-INFIELD_SIZE/2, 0, -INFIELD_SIZE/2);
            
            // Second base is at the top-left corner of the infield
            const secondBaseCorner = new THREE.Vector3(-INFIELD_SIZE/2, 0, INFIELD_SIZE/2);
            
            // Third base is at the bottom-left corner of the infield
            const thirdBaseCorner = new THREE.Vector3(INFIELD_SIZE/2, 0, INFIELD_SIZE/2);
            
            // Create ground plane
            const groundPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, // Lawn green
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                })
            );
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -0.02;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
            
            // Create fair territory (yellow area)
            const fairTerritory = new THREE.Mesh(
                new THREE.PlaneGeometry(FAIR_TERRITORY_SIZE, FAIR_TERRITORY_SIZE),
                new THREE.MeshStandardMaterial({ 
                    color: FAIR_TERRITORY_COLOR,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                })
            );
            fairTerritory.rotation.x = -Math.PI / 2;
            fairTerritory.position.set(0, 0, 0);
            fairTerritory.receiveShadow = true;
            scene.add(fairTerritory);
            
            // Create infield (gray area)
            const infield = new THREE.Mesh(
                new THREE.PlaneGeometry(INFIELD_SIZE, INFIELD_SIZE),
                new THREE.MeshStandardMaterial({ 
                    color: INFIELD_COLOR,
                    roughness: 0.9,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                })
            );
            infield.rotation.x = -Math.PI / 2;
            infield.position.set(0, 0.01, 0); // Slightly above fair territory
            infield.receiveShadow = true;
            scene.add(infield);
            
            // Create batter's box
            const battersBox = new THREE.Mesh(
                new THREE.PlaneGeometry(BATTERS_BOX_SIZE, BATTERS_BOX_SIZE),
                new THREE.MeshStandardMaterial({ 
                    color: BATTERS_BOX_COLOR,
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                })
            );
            battersBox.rotation.x = -Math.PI / 2;
            battersBox.position.set(
                homePos.x + BATTERS_BOX_SIZE/2, 
                0.015, // Slightly above the field
                homePos.z - BATTERS_BOX_SIZE/2
            );
            // battersBox.receiveShadow = true;
            scene.add(battersBox);
            
            // Create no-hit zone (triangle from home plate into infield)
            function createNoHitZone() {
                // Create a triangular shape for the no-hit zone
                const noHitShape = new THREE.Shape();
                
                // Start at home plate
                noHitShape.moveTo(homePos.x, homePos.z);
                
                // Point at 4.5m INSIDE the field along the x-axis (toward third base)
                noHitShape.lineTo(homePos.x - NO_HIT_DISTANCE, homePos.z);
                
                // Point at 4.5m INSIDE the field along the z-axis (toward first base)
                noHitShape.lineTo(homePos.x, homePos.z + NO_HIT_DISTANCE);
                
                // Back to home plate
                noHitShape.lineTo(homePos.x, homePos.z);
                
                // Create geometry from the shape
                const noHitGeometry = new THREE.ShapeGeometry(noHitShape);
                
                // Create material with transparency
                const noHitMaterial = new THREE.MeshBasicMaterial({
                    color: NO_HIT_ZONE_COLOR,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                
                // Create mesh
                const noHitZone = new THREE.Mesh(noHitGeometry, noHitMaterial);
                noHitZone.rotation.x = Math.PI / 2;
                noHitZone.position.y = 0.02; // Slightly above the field
                
                return noHitZone;
            }

            // Create the no-hit zone line
            function createNoHitLine() {
                const points = [
                    new THREE.Vector3(homePos.x - NO_HIT_DISTANCE, 0.03, homePos.z), // Point INSIDE toward third base
                    new THREE.Vector3(homePos.x, 0.03, homePos.z + NO_HIT_DISTANCE)  // Point INSIDE toward first base
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xFF0000, linewidth: 3 });
                
                return new THREE.Line(geometry, material);
            }
            
            // Add the no-hit zone and line to the scene
            const noHitZone = createNoHitZone();
            scene.add(noHitZone);
            
            const noHitLine = createNoHitLine();
            scene.add(noHitLine);
            
            // Create bases with labels
            function createBase(position, type) {
                const baseGroup = new THREE.Group();
                
                // Create the base
               
                const baseGeometry = new THREE.BoxGeometry(BASE_SIZE, 0.05, BASE_SIZE);
                const baseMaterial = new THREE.MeshStandardMaterial({ 
                    color: BASE_COLOR,
                    roughness: 0.5,
                    metalness: 0.3
                });
                
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(0, 0.025, 0);
                base.castShadow = true;
                base.receiveShadow = true;
                baseGroup.add(base);
                
                
                // Add a label to identify the base
                // Create a canvas for the texture
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                
                // Fill with white
                context.fillStyle = '#FFFFFF';
                context.fillRect(0, 0, 128, 128);
                
                // Add text
                context.fillStyle = '#000000';
                context.font = 'bold 80px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                let label = '';
                if (type === 'home') label = 'F';
                else if (type === 'runner-home') label = 'R';
                else if (type === 'runners') label = '1R';
                else if (type === 'first') label = '1F';
                else if (type === 'second') label = '2';
                else if (type === 'third') label = '3';
                
                context.fillText(label, 64, 64);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                
                // Create a plane for the label
                 let baseSize = BASE_SIZE;
                if (type === 'safety') {
                    baseSize = RUNNERS_BASE_SIZE;
                }else{
                    baseSize = BASE_SIZE;
                }
                const labelGeometry = new THREE.PlaneGeometry(baseSize, BASE_SIZE);
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
                
                const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                labelMesh.rotation.x = -Math.PI / 2;
                labelMesh.position.y = 0.051; // Just above the base
                baseGroup.add(labelMesh);
                
                // Position the entire group
                baseGroup.position.copy(position);
                
                return baseGroup;
            }
            
            // Home plate (with special shape for home)
            const homeBase = createBase(
                new THREE.Vector3(homePos.x - BASE_SIZE/2, 0, homePos.z + BASE_SIZE/2),
                'home'
            );
            const runnerHomeBase = createBase(
                new THREE.Vector3(homePos.x + BASE_SIZE/2, 0, homePos.z + BASE_SIZE/2),
                'runner-home'
            );
            scene.add(runnerHomeBase);
            scene.add(homeBase);
            
            // third  base (in fair territory) - now at the top-right corner
            
            const thirdBase = createBase(
                new THREE.Vector3(thirdBaseCorner.x - BASE_SIZE/2, 0, thirdBaseCorner.z + BASE_SIZE/2),
                'third'
            );
            scene.add(thirdBase);
            
            // First base safety base (in foul territory)
            const safetyBase = createBase(
                new THREE.Vector3(firstBaseCorner.x - BASE_SIZE*1.5, 0, firstBaseCorner.z - BASE_SIZE/2),
                'safety'
            );
            // Change the color of the safety base to orange
            safetyBase.children[0].material = new THREE.MeshStandardMaterial({ 
                color: SAFE_AREA_COLOR,
                roughness: 0.5,
                metalness: 0.3
            });
            scene.add(safetyBase);
            
            // Safe area at first base
            const safeAreaGeometry = new THREE.PlaneGeometry(SAFE_AREA_WIDTH, BASE_SIZE);
            const safeAreaMaterial = new THREE.MeshBasicMaterial({
                color: '#FFFFFF',
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.4
            });
            
            const safeArea = new THREE.Mesh(safeAreaGeometry, safeAreaMaterial);
            safeArea.rotation.x = -Math.PI / 2;
            safeArea.position.set(
                firstBaseCorner.x - BASE_SIZE - SAFE_AREA_WIDTH/2, 
                0.015, 
                firstBaseCorner.z - BASE_SIZE/2
            );
            scene.add(safeArea);
            
            // Second base
            const secondBase = createBase(
                new THREE.Vector3(secondBaseCorner.x - BASE_SIZE/2, 0, secondBaseCorner.z + BASE_SIZE/2),
                'second'
            );
            scene.add(secondBase);
            
            // Third base - now at the bottom-left corner
            const firstBase = createBase(
                new THREE.Vector3(firstBaseCorner.x - BASE_SIZE/2, 0, firstBaseCorner.z + BASE_SIZE/2),
                'first'
            );
             const runnersBase = createBase(
                new THREE.Vector3(firstBaseCorner.x - BASE_SIZE/2, 0, firstBaseCorner.z -BASE_SIZE/2),
                'runners'
            );

            scene.add(firstBase);
            scene.add(runnersBase);
            
            // Create field lines
            // Infield lines
            function createLine(start, end, color = 0x000000, linewidth = 2) {
                const points = [
                    new THREE.Vector3(start.x, 0.03, start.z),
                    new THREE.Vector3(end.x, 0.03, end.z)
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color, linewidth });
                
                return new THREE.Line(geometry, material);
            }
            
            // Infield lines
            scene.add(createLine(homePos, firstBaseCorner));
            scene.add(createLine(firstBaseCorner, secondBaseCorner));
            scene.add(createLine(secondBaseCorner, thirdBaseCorner));
            scene.add(createLine(thirdBaseCorner, homePos));
            
            // Foul lines
            scene.add(createLine(
                homePos, 
                new THREE.Vector3(homePos.x, 0.03, homePos.z + FAIR_TERRITORY_SIZE-2.5),
                0xFF0000
            ));
            scene.add(createLine(
                homePos, 
                new THREE.Vector3(homePos.x - FAIR_TERRITORY_SIZE + 2.5, 0.03, homePos.z),
                0xFF0000
            ));
            
            // Batter's box outline
            const boxPoints = [
                new THREE.Vector3(homePos.x, 0.03, homePos.z),
                new THREE.Vector3(homePos.x - BATTERS_BOX_SIZE, 0.03, homePos.z),
                new THREE.Vector3(homePos.x - BATTERS_BOX_SIZE, 0.03, homePos.z - BATTERS_BOX_SIZE),
                new THREE.Vector3(homePos.x, 0.03, homePos.z - BATTERS_BOX_SIZE),
                new THREE.Vector3(homePos.x, 0.03, homePos.z)
            ];
            
          
            
            // Create fences
            const fenceHeight = FENCE_HEIGHT;
            const fenceThickness = 0.05;
            
            // Left fence
            const leftFence = new THREE.Mesh(
                new THREE.BoxGeometry(fenceThickness, fenceHeight, FAIR_TERRITORY_SIZE),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            leftFence.position.set(-FAIR_TERRITORY_SIZE/2 - fenceThickness/2, fenceHeight/2, 0);
            leftFence.castShadow = true;
            scene.add(leftFence);
            
            // Top fence
            const topFence = new THREE.Mesh(
                new THREE.BoxGeometry(FAIR_TERRITORY_SIZE + fenceThickness*2, fenceHeight, fenceThickness),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            topFence.position.set(0, fenceHeight/2, FAIR_TERRITORY_SIZE/2 + fenceThickness/2);
            topFence.castShadow = true;
            scene.add(topFence);
            
            // Right fence
            const rightFence = new THREE.Mesh(
                new THREE.BoxGeometry(fenceThickness, fenceHeight, FAIR_TERRITORY_SIZE-4.5),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            rightFence.position.set(FAIR_TERRITORY_SIZE/2 - fenceThickness/2, fenceHeight/2, 2.25);
            rightFence.castShadow = true;
            scene.add(rightFence);
            
            // Bottom fence
            const bottomFence = new THREE.Mesh(
                new THREE.BoxGeometry(FAIR_TERRITORY_SIZE-4.5, fenceHeight, fenceThickness),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            bottomFence.position.set(-2.25, fenceHeight/2, -FAIR_TERRITORY_SIZE/2 - fenceThickness/2);
            bottomFence.castShadow = true;
            scene.add(bottomFence);

            // Create a sporty player with t-shirt and shorts (simplified arms, no ball)
            function createPlayer() {
                const playerGroup = new THREE.Group();
                
                // Create the player body (athletic torso with t-shirt)
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.22, 0.6, 16);
                const tshirtMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00BFFF, // Bright blue t-shirt
                    roughness: 0.8,
                    metalness: 0.1
                });
                const body = new THREE.Mesh(bodyGeometry, tshirtMaterial);
                body.position.y = 0.65; // Position above ground
                playerGroup.add(body);
                
                // Create the player head (sphere)
                const headGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const skinMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xE0AC69, // Skin tone
                    roughness: 0.7,
                    metalness: 0.1
                });
                const head = new THREE.Mesh(headGeometry, skinMaterial);
                head.position.y = 1.1; // Position above body
                playerGroup.add(head);
                
                // Create the player shorts (boxier, shorter than pants)
                const shortsGeometry = new THREE.BoxGeometry(0.28, 0.25, 0.22);
                const shortsMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333, // Dark shorts
                    roughness: 0.7,
                    metalness: 0.1
                });
                const shorts = new THREE.Mesh(shortsGeometry, shortsMaterial);
                shorts.position.y = 0.3; // Position below torso
                playerGroup.add(shorts);
                
                // Create the player legs (exposed below shorts)
                const thighGeometry = new THREE.CylinderGeometry(0.08, 0.07, 0.25, 16);
                const calfGeometry = new THREE.CylinderGeometry(0.07, 0.05, 0.25, 16);
                
                // Left thigh - slightly bent for athletic pose
                const leftThigh = new THREE.Mesh(thighGeometry, skinMaterial);
                leftThigh.position.set(-0.1, 0.15, 0.05);
                leftThigh.rotation.x = Math.PI * 0.05; // Slight forward bend
                playerGroup.add(leftThigh);
                
                // Left calf
                const leftCalf = new THREE.Mesh(calfGeometry, skinMaterial);
                leftCalf.position.set(-0.1, -0.05, 0.1);
                playerGroup.add(leftCalf);
                
                // Right thigh - in stride position
                const rightThigh = new THREE.Mesh(thighGeometry, skinMaterial);
                rightThigh.position.set(0.1, 0.15, -0.05);
                rightThigh.rotation.x = -Math.PI * 0.1; // Backward stride
                playerGroup.add(rightThigh);
                
                // Right calf
                const rightCalf = new THREE.Mesh(calfGeometry, skinMaterial);
                rightCalf.position.set(0.1, -0.05, -0.1);
                playerGroup.add(rightCalf);
                
                // Create athletic shoes
                const shoeGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.2);
                const shoeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF, // White athletic shoes
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                // Left shoe
                const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                leftShoe.position.set(-0.1, -0.2, 0.15);
                playerGroup.add(leftShoe);
                
                // Right shoe
                const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                rightShoe.position.set(0.1, -0.2, -0.15);
                playerGroup.add(rightShoe);
                
                // Create simplified arms (straight cylinders)
                const armGeometry = new THREE.CylinderGeometry(0.06, 0.05, 0.5, 16);
                
                // Left arm (t-shirt color for upper, skin for lower)
                const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
                leftArm.position.set(-0.3, 0.65, 0);
                leftArm.rotation.z = Math.PI * 0.25; // Angled outward
                playerGroup.add(leftArm);
                
                // Right arm (t-shirt color for upper, skin for lower)
                const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
                rightArm.position.set(0.3, 0.65, 0);
                rightArm.rotation.z = -Math.PI * 0.25; // Angled outward
                playerGroup.add(rightArm);
                
                // Create hands
                const handGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                
                // Add a sporty cap
                const capGeometry = new THREE.CylinderGeometry(0.17, 0.17, 0.08, 16);
                const capBrimGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.2);
                const capMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00BFFF, // Match t-shirt
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                // Cap body
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = 1.2;
                playerGroup.add(cap);
                
                // Cap brim
                const capBrim = new THREE.Mesh(capBrimGeometry, capMaterial);
                capBrim.position.set(0, 1.16, 0.12);
                playerGroup.add(capBrim);
                
                // Add t-shirt logo (Baseball5)
                const logoCanvas = document.createElement('canvas');
                logoCanvas.width = 128;
                logoCanvas.height = 128;
                const logoContext = logoCanvas.getContext('2d');
                
                // Fill with t-shirt color
                logoContext.fillStyle = '#00BFFF';
                logoContext.fillRect(0, 0, 128, 128);
                
                // Add text
                logoContext.fillStyle = '#FFFFFF';
                logoContext.font = 'bold 24px Arial';
                logoContext.textAlign = 'center';
                logoContext.textBaseline = 'middle';
                logoContext.fillText('BASEBALL5', 64, 64);
                
                // Create texture from canvas
                const logoTexture = new THREE.CanvasTexture(logoCanvas);
                
                // Create a plane for the logo
                const logoGeometry = new THREE.PlaneGeometry(0.2, 0.1);
                const logoMaterial = new THREE.MeshBasicMaterial({
                    map: logoTexture,
                    transparent: true
                });
                
                const logo = new THREE.Mesh(logoGeometry, logoMaterial);
                logo.position.set(0, 0.7, 0.31); // Center front of t-shirt
                logo.rotation.x = Math.PI * 0.05; // Align with t-shirt
                playerGroup.add(logo);
                
                // Position the player in the middle of the field
                playerGroup.position.set(0, 0, 0);
                // Rotate slightly to face toward home plate
                playerGroup.rotation.y = Math.PI * 0.25;
                
                // Add shadow casting
                playerGroup.traverse((object) => {
                    if (object.isMesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
                
                return playerGroup;
            }
            
            // Add first player to the scene - positioned closer to second base
            const midfieldPlayer = createPlayer();
            // Move player closer to second base (top-left corner of infield)
            midfieldPlayer.position.set(-INFIELD_SIZE/9, 0, INFIELD_SIZE/9);
            // Rotate to face toward home plate
            midfieldPlayer.rotation.y = Math.PI * 0.8; // Adjusted rotation to face home plate from new position
            scene.add(midfieldPlayer);
            
            // Create a first base player near first base (corrected position)
            const thirdBasePlayer = createPlayer();
            // Move player closer to second base (top-left corner of infield)
            thirdBasePlayer.position.set(INFIELD_SIZE/2.5, 0, INFIELD_SIZE/1.9);
            // Rotate to face toward home plate
            thirdBasePlayer.rotation.y = Math.PI * 1; // Adjusted rotation to face home plate from new position
            scene.add(thirdBasePlayer);

            const firstBasePlayer = createPlayer();
            // Move player closer to second base (top-left corner of infield)
            firstBasePlayer.position.set(-INFIELD_SIZE/1.9, 0, -INFIELD_SIZE/2.7);
            // Rotate to face toward home plate
            firstBasePlayer.rotation.y = Math.PI * 0.5; // Adjusted rotation to face home plate from new position
            scene.add(firstBasePlayer);

            const secondBasePlayer = createPlayer();
            // Move player closer to second base (top-left corner of infield)
            secondBasePlayer.position.set(-INFIELD_SIZE/1.6, 0, INFIELD_SIZE/9);
            // Rotate to face toward home plate
            secondBasePlayer.rotation.y = Math.PI * 0.7; // Adjusted rotation to face home plate from new position
            scene.add(secondBasePlayer);

            const shortstopPlayer = createPlayer();
            // Move player closer to second base (top-left corner of infield)
            shortstopPlayer.position.set(-INFIELD_SIZE/9, 0, INFIELD_SIZE/1.6);
            // Rotate to face toward home plate
            shortstopPlayer.rotation.y = Math.PI * 0.9; // Adjusted rotation to face home plate from new position
            scene.add(shortstopPlayer);
            
            // Create a batter (red shirt) in the batting box
            function createBatter() {
                // Clone the player creation function but with red shirt
                const playerGroup = createPlayer();
                
                // Change shirt and cap color to red
                playerGroup.traverse((object) => {
                    if (object.isMesh) {
                        // If it's the t-shirt or cap, change the color to red
                        if (object.material && 
                            (object.material.color.getHex() === 0x00BFFF || 
                             object.material.color.getHex() === 0x00BFFF)) {
                            object.material = object.material.clone(); // Clone the material
                            object.material.color.setHex(0xFF0000); // Bright red
                        }
                    }
                });
                
                // Modify pose to batting stance
                playerGroup.traverse((object) => {
                    // Find right arm and adjust to batting position
                    if (object.isMesh && object.position.x > 0.2 && object.position.y > 0.4 && object.position.y < 0.7) {
                        // Right arm raised for batting
                        object.rotation.z = -Math.PI * 0.5; // Raised higher
                        object.rotation.y = Math.PI * 0.2; // Rotated back
                    }
                    // Find left arm and adjust to batting position
                    if (object.isMesh && object.position.x < -0.2 && object.position.y > 0.4 && object.position.y < 0.7) {
                        // Left arm raised for batting
                        object.rotation.z = Math.PI * 0.5; // Raised higher
                        object.rotation.y = -Math.PI * 0.2; // Rotated back
                    }
                });
                
                // Position in batting box
                playerGroup.position.set(
                    homePos.x - BATTERS_BOX_SIZE/2 + 0.5, // Center of batting box
                    0,
                    homePos.z - BATTERS_BOX_SIZE/2 + 0.5
                );
                
                // Rotate to face the field
                playerGroup.rotation.y = Math.PI * 0.25;
                
                return playerGroup;
            }
            
            // Add batter to the scene
            const batter = createBatter();
            scene.add(batter);
            
            // Add animation of ball from batting box to third base player to first base player
            // with batter running to first base
            function createBallAndBatterAnimation() {
                // Create the ball
                const ballGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const ballMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF, // White ball
                    roughness: 0.5,
                    metalness: 0.2
                });
                const ball = new THREE.Mesh(ballGeometry, ballMaterial);
                ball.castShadow = true;
                
                // Define positions for the animation sequence
                // 1. Batting box position (starting point)
                const battingBoxPosition = new THREE.Vector3(
                    homePos.x - BATTERS_BOX_SIZE/2 + 0.5, 
                    0.3, // Slightly above ground
                    homePos.z - BATTERS_BOX_SIZE/2 + 0.5
                );
                
                // 2. Third base player's hand position
                const thirdBasePlayerPosition = new THREE.Vector3(
                    thirdBasePlayer.position.x + 0.45 * Math.cos(thirdBasePlayer.rotation.y),
                    0.45, // Hand height
                    thirdBasePlayer.position.z + 0.45 * Math.sin(thirdBasePlayer.rotation.y)
                );
                
                // 3. First base player's hand position
                const firstBasePlayerPosition = new THREE.Vector3(
                    firstBasePlayer.position.x + 0.45 * Math.cos(firstBasePlayer.rotation.y),
                    0.45, // Hand height
                    firstBasePlayer.position.z + 0.45 * Math.sin(firstBasePlayer.rotation.y)
                );
                
                // First base position (for batter to run to)
                const firstBasePosition = new THREE.Vector3(
                    firstBasePlayer.position.x, 
                    0,
                    -INFIELD_SIZE/2
                );
                
                // Set initial position
                ball.position.copy(battingBoxPosition);
                scene.add(ball);
                
                // Animation parameters
                const segmentDuration = 1.5; // seconds per segment
                const maxHeight = 1.5; // maximum height of the arc
                let animationTime = 0;
                let currentSegment = 0; // 0: batting box to third, 1: third to first, 2: first to third
                let batterRunning = false; // Flag to track if batter has started running
                let batterReachedBase = false; // Flag to track if batter has reached first base
                let resetAnimation = false; // Flag to reset the entire animation
                const resetDelay = 2.0; // Seconds to wait before resetting
                let resetTimer = 0;
                
                // Animation function
                function animateBallAndBatter(time) {
                    const deltaTime = clock.getDelta();
                    
                    // Check if we need to reset the entire animation
                    if (resetAnimation) {
                        resetTimer += deltaTime;
                        if (resetTimer >= resetDelay) {
                            // Reset everything
                            animationTime = 0;
                            currentSegment = 0;
                            batterRunning = false;
                            batterReachedBase = false;
                            resetAnimation = false;
                            resetTimer = 0;
                            
                            // Reset ball position
                            ball.position.copy(battingBoxPosition);
                            
                            // Reset batter position
                            batter.position.set(
                                homePos.x - BATTERS_BOX_SIZE/2 + 0.5,
                                0,
                                homePos.z - BATTERS_BOX_SIZE/2 + 0.5
                            );
                            batter.rotation.y = Math.PI * 0.25;
                            
                            // Make batter visible again
                            batter.visible = true;
                        }
                        requestAnimationFrame(animateBallAndBatter);
                        return;
                    }
                    
                    // Update animation time
                    animationTime += deltaTime;
                    
                    // Check if we need to move to the next segment
                    if (animationTime >= segmentDuration) {
                        animationTime = 0;
                        currentSegment++;
                        
                        // Start batter running after ball is hit
                        if (currentSegment === 1) {
                            batterRunning = true;
                        }
                        
                        // Reset animation after completing the cycle
                        if (currentSegment > 2) {
                            resetAnimation = true;
                            requestAnimationFrame(animateBallAndBatter);
                            return;
                        }
                    }
                    
                    // Calculate progress (0 to 1) within current segment
                    const progress = animationTime / segmentDuration;
                    
                    // Determine start and end positions for current segment
                    let startPos, endPos;
                    
                    if (currentSegment === 0) {
                        // Batting box to third base player
                        startPos = battingBoxPosition;
                        endPos = thirdBasePlayerPosition;
                    } else if (currentSegment === 1) {
                        // Third base player to first base player
                        startPos = thirdBasePlayerPosition;
                        endPos = firstBasePlayerPosition;
                    } else {
                        // First base player back to third base player
                        startPos = firstBasePlayerPosition;
                        endPos = thirdBasePlayerPosition;
                    }
                    
                    // Linear interpolation for x and z
                    ball.position.x = startPos.x + (endPos.x - startPos.x) * progress;
                    ball.position.z = startPos.z + (endPos.z - startPos.z) * progress;
                    
                    // Parabolic arc for y (height)
                    ball.position.y = startPos.y + 4 * maxHeight * progress * (1 - progress);
                    
                    // Add rotation to the ball
                    ball.rotation.x += 0.1;
                    ball.rotation.z += 0.1;
                    
                    // Animate batter running to first base
                    if (batterRunning && !batterReachedBase) {
                        // Calculate running progress (slower than the ball)
                        const runProgress = Math.min(1.0, (animationTime + (currentSegment - 1) * segmentDuration) / (segmentDuration * 2));
                        
                        // Move batter toward first base
                        batter.position.x = battingBoxPosition.x + (firstBasePosition.x - battingBoxPosition.x) * runProgress;
                        batter.position.z = battingBoxPosition.z + (firstBasePosition.z - battingBoxPosition.z) * runProgress;
                        
                        // Rotate batter to face running direction
                        batter.rotation.y = Math.atan2(
                            firstBasePosition.z - battingBoxPosition.z,
                            firstBasePosition.x - battingBoxPosition.x
                        );
                        
                        // Check if batter has reached first base
                        if (runProgress >= 1.0) {
                            batterReachedBase = true;
                        }
                    }
                    
                    // Request next frame
                    requestAnimationFrame(animateBallAndBatter);
                }
                
                // Start animation
                requestAnimationFrame(animateBallAndBatter);
                
                return ball;
            }
            
            // Create a clock for timing animations
            const clock = new THREE.Clock();
            
            // Add the ball and batter animation
            const animatedBall = createBallAndBatterAnimation();
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Reset camera to initial position
        function resetCamera() {
            camera.position.set(0, 20, 20);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        // Toggle legend visibility
        function toggleLegend() {
            const legend = document.getElementById('legend');
            legend.style.display = legend.style.display === 'none' ? 'block' : 'none';
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize the scene when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
