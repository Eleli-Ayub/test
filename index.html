<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baseball5 Field</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .toggle-btn {
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 14px;
            min-width: 200px;
            text-align: left;
        }
        .toggle-btn:hover {
            background-color: rgba(0,0,0,0.9);
        }
    </style>
</head>
<body>
    <div id="info">Baseball5 Field - Drag to rotate, scroll to zoom</div>
    <div id="controls">
        <button id="dimensionToggle" class="toggle-btn">Toggle Dimensions</button>
        <button id="baseNamesToggle" class="toggle-btn">Toggle Base Names</button>
    </div>

    <script>
        // Field dimensions (in meters)
        const outerFieldSize = 21; // 21m x 21m (including foul territory)
        const fairFieldSize = 18; // 18m x 18m (fair territory)
        const infieldSize = 13; // 13m x 13m (infield square)
        const battersBoxSize = 3; // 3m x 3m
        const noHitZoneDistance = 4.5; // 4.5m from home plate (3m for U-15)
        const baseSize = 0.6; // 60cm x 60cm for all bases
        
        // Half sizes for positioning
        const outerHalfSize = outerFieldSize / 2;
        const fairHalfSize = fairFieldSize / 2;
        const inHalfSize = infieldSize / 2;
        
        // Set up scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        
        // Set up camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 20);
        camera.lookAt(0, 0, 0);
        
        // Set up renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        // Add directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Create ground plane with colored regions
        // Outer field (light gray)
        const outerFieldGeometry = new THREE.PlaneGeometry(outerFieldSize, outerFieldSize);
        const outerFieldMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xCCCCCC, 
            side: THREE.DoubleSide 
        });
        const outerField = new THREE.Mesh(outerFieldGeometry, outerFieldMaterial);
        outerField.rotation.x = -Math.PI / 2;
        outerField.position.y = 0;
        scene.add(outerField);

        // Fair territory (green)
        const fairFieldGeometry = new THREE.PlaneGeometry(fairFieldSize, fairFieldSize);
        const fairFieldMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x90EE90, // Light green
            side: THREE.DoubleSide 
        });
        const fairField = new THREE.Mesh(fairFieldGeometry, fairFieldMaterial);
        fairField.rotation.x = -Math.PI / 2;
        fairField.position.y = 0.005;
        scene.add(fairField);

        // Infield (darker green)
        const infieldGeometry = new THREE.PlaneGeometry(infieldSize, infieldSize);
        const infieldMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x228B22, // Forest green
            side: THREE.DoubleSide 
        });
        const infield = new THREE.Mesh(infieldGeometry, infieldMaterial);
        infield.rotation.x = -Math.PI / 2;
        infield.position.y = 0.01;
        scene.add(infield);

        // Draw field lines
        const linesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF, linewidth: 2 });

        // Outer field lines
        const outerFieldLines = [];
        outerFieldLines.push(new THREE.Vector3(-outerHalfSize, 0.02, -outerHalfSize));
        outerFieldLines.push(new THREE.Vector3(outerHalfSize, 0.02, -outerHalfSize));
        outerFieldLines.push(new THREE.Vector3(outerHalfSize, 0.02, outerHalfSize));
        outerFieldLines.push(new THREE.Vector3(-outerHalfSize, 0.02, outerHalfSize));
        outerFieldLines.push(new THREE.Vector3(-outerHalfSize, 0.02, -outerHalfSize));
        
        const outerFieldLineGeometry = new THREE.BufferGeometry().setFromPoints(outerFieldLines);
        const outerFieldLine = new THREE.Line(outerFieldLineGeometry, linesMaterial);
        scene.add(outerFieldLine);

        // Fair territory lines
        const fairFieldLines = [];
        fairFieldLines.push(new THREE.Vector3(-fairHalfSize, 0.02, -fairHalfSize));
        fairFieldLines.push(new THREE.Vector3(fairHalfSize, 0.02, -fairHalfSize));
        fairFieldLines.push(new THREE.Vector3(fairHalfSize, 0.02, fairHalfSize));
        fairFieldLines.push(new THREE.Vector3(-fairHalfSize, 0.02, fairHalfSize));
        fairFieldLines.push(new THREE.Vector3(-fairHalfSize, 0.02, -fairHalfSize));
        
        const fairFieldLineGeometry = new THREE.BufferGeometry().setFromPoints(fairFieldLines);
        const fairFieldLine = new THREE.Line(fairFieldLineGeometry, linesMaterial);
        scene.add(fairFieldLine);

        // Infield lines
        const infieldLines = [];
        infieldLines.push(new THREE.Vector3(-inHalfSize, 0.02, -inHalfSize));
        infieldLines.push(new THREE.Vector3(inHalfSize, 0.02, -inHalfSize));
        infieldLines.push(new THREE.Vector3(inHalfSize, 0.02, inHalfSize));
        infieldLines.push(new THREE.Vector3(-inHalfSize, 0.02, inHalfSize));
        infieldLines.push(new THREE.Vector3(-inHalfSize, 0.02, -inHalfSize));
        
        const infieldLineGeometry = new THREE.BufferGeometry().setFromPoints(infieldLines);
        const infieldLine = new THREE.Line(infieldLineGeometry, linesMaterial);
        scene.add(infieldLine);

        // Calculate base positions according to the official specifications
        // Home plate at the corner of the infield
        const homePos = new THREE.Vector3(-inHalfSize, 0.02, -inHalfSize);
        
        // The infield corners
        const firstBaseCorner = new THREE.Vector3(-inHalfSize, 0.02, inHalfSize);
        const secondBaseCorner = new THREE.Vector3(inHalfSize, 0.02, inHalfSize);
        const thirdBaseCorner = new THREE.Vector3(inHalfSize, 0.02, -inHalfSize);

        // Third base line (from home to right edge of fair territory)
        const thirdBaseLinePoints = [];
        thirdBaseLinePoints.push(new THREE.Vector3(homePos.x, 0.03, homePos.z)); // Start at home plate
        
        // For the third base line, we'll go straight right from home plate to the edge of fair territory
        thirdBaseLinePoints.push(new THREE.Vector3(fairHalfSize, 0.03, homePos.z));
        
        const thirdBaseLineGeometry = new THREE.BufferGeometry().setFromPoints(thirdBaseLinePoints);
        const thirdBaseLine = new THREE.Line(thirdBaseLineGeometry, new THREE.LineBasicMaterial({ color: 0xFFFFFF, linewidth: 2 }));
        scene.add(thirdBaseLine);

        // Add foul lines extending from home plate to the edge of the field
        // First base line (from home to first and beyond to the edge of fair territory)
        const firstBaseLinePoints = [];
        firstBaseLinePoints.push(new THREE.Vector3(homePos.x, 0.03, homePos.z)); // Start at home plate
        
        // Calculate direction vector from home to first base corner
        const homeToFirstDir = new THREE.Vector3().subVectors(firstBaseCorner, homePos).normalize();
        
        // Find where the line intersects with the edge of the fair territory
        // For the first base line, we need to find where it intersects with the top edge of fair territory (z = fairHalfSize)
        const t1 = (fairHalfSize - homePos.z) / homeToFirstDir.z;
        const firstBaseLineEnd = new THREE.Vector3(
            homePos.x + homeToFirstDir.x * t1,
            0.03,
            fairHalfSize // Top edge of fair territory
        );
        
        // Make sure the line doesn't extend beyond the edge of the field
        if (firstBaseLineEnd.x < -fairHalfSize) {
            // If it would extend beyond the left edge, cap it at the left edge
            const t2 = (-fairHalfSize - homePos.x) / homeToFirstDir.x;
            firstBaseLineEnd.x = -fairHalfSize;
            firstBaseLineEnd.z = homePos.z + homeToFirstDir.z * t2;
        }
        
        firstBaseLinePoints.push(firstBaseLineEnd);
        
        const firstBaseLineGeometry = new THREE.BufferGeometry().setFromPoints(firstBaseLinePoints);
        const firstBaseLine = new THREE.Line(firstBaseLineGeometry, new THREE.LineBasicMaterial({ color: 0xFFFFFF, linewidth: 2 }));
        scene.add(firstBaseLine);

        // Function to create standard base marker - exactly 60cm x 60cm
        function createBaseMarker(position) {
            const baseGeometry = new THREE.PlaneGeometry(baseSize, baseSize);
            const baseMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF, 
                side: THREE.DoubleSide 
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.rotation.x = -Math.PI / 2;
            base.position.copy(position);
            base.position.y = 0.02;
            
            // Add a border to the base
            const baseEdgeGeometry = new THREE.EdgesGeometry(baseGeometry);
            const baseEdges = new THREE.LineSegments(
                baseEdgeGeometry,
                new THREE.LineBasicMaterial({ color: 0x000000 })
            );
            base.add(baseEdges);
            
            return base;
        }

        // Function to create a base that starts at a corner and extends outward
        function createCornerBase(cornerPos, dirX, dirZ) {
            const baseGeometry = new THREE.PlaneGeometry(baseSize, baseSize);
            const baseMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF, 
                side: THREE.DoubleSide 
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.rotation.x = -Math.PI / 2;
            
            // Position the base so one of its corners is at the infield corner
            // and it extends outward in the specified direction
            base.position.set(
                cornerPos.x + (dirX * baseSize/2), // Shift center in X direction
                0.02,
                cornerPos.z + (dirZ * baseSize/2)  // Shift center in Z direction
            );
            
            // Add a border to the base
            const baseEdgeGeometry = new THREE.EdgesGeometry(baseGeometry);
            const baseEdges = new THREE.LineSegments(
                baseEdgeGeometry,
                new THREE.LineBasicMaterial({ color: 0x000000 })
            );
            base.add(baseEdges);
            
            return base;
        }

        // Function to create home plate - also 60cm x 60cm
        function createHomePlate() {
            // Using standard base size for home plate as well (60cm x 60cm)
            const baseGeometry = new THREE.PlaneGeometry(baseSize, baseSize);
            const baseMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF, 
                side: THREE.DoubleSide 
            });
            const homePlate = new THREE.Mesh(baseGeometry, baseMaterial);
            homePlate.rotation.x = -Math.PI / 2;
            homePlate.position.copy(homePos);
            homePlate.position.y = 0.02;
            
            // Add a border to the base
            const baseEdgeGeometry = new THREE.EdgesGeometry(baseGeometry);
            const baseEdges = new THREE.LineSegments(
                baseEdgeGeometry,
                new THREE.LineBasicMaterial({ color: 0x000000 })
            );
            homePlate.add(baseEdges);
            
            return homePlate;
        }

        // Create home plate
        const homePlate = createHomePlate();
        scene.add(homePlate);

        // Create first base - starts at corner and extends up and left
        const firstBase = createCornerBase(firstBaseCorner, -1, 1);
        scene.add(firstBase);
        
        // Create safety base (in foul territory next to first base)
        const firstBasePos = new THREE.Vector3(
            firstBaseCorner.x - baseSize/2,
            0.02,
            firstBaseCorner.z + baseSize/2
        );
        const safetyBasePos = new THREE.Vector3(
            firstBasePos.x - baseSize, 
            firstBasePos.y, 
            firstBasePos.z
        );
        const safetyBase = createBaseMarker(safetyBasePos);
        safetyBase.material = new THREE.MeshBasicMaterial({ 
            color: 0xFFA500, // Orange for visibility
            side: THREE.DoubleSide 
        });
        scene.add(safetyBase);

        // Create second base - starts at corner and extends up and right
        const secondBase = createCornerBase(secondBaseCorner, 1, 1);
        scene.add(secondBase);

        // Create third base - starts at corner and extends down and right
        const thirdBase = createCornerBase(thirdBaseCorner, 1, -1);
        scene.add(thirdBase);
        
        // Update positions for labels
        const firstPos = new THREE.Vector3(
            firstBaseCorner.x - baseSize/2,
            0.02,
            firstBaseCorner.z + baseSize/2
        );
        
        const secondPos = new THREE.Vector3(
            secondBaseCorner.x + baseSize/2,
            0.02,
            secondBaseCorner.z + baseSize/2
        );
        
        const thirdPos = new THREE.Vector3(
            thirdBaseCorner.x + baseSize/2,
            0.02,
            thirdBaseCorner.z - baseSize/2
        );

        // Create dimension labels
        const dimensionLabels = new THREE.Group();
        // All dimension labels removed

        scene.add(dimensionLabels);
        dimensionLabels.visible = false;

        // Create base name labels
        function createBaseLabel(text, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            context.fillStyle = 'rgba(255, 255, 255, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 36px Arial';
            context.fillStyle = 'black';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(2, 1);
            const label = new THREE.Mesh(geometry, material);
            label.position.copy(position);
            label.position.y = 0.1;
            label.rotation.x = -Math.PI / 2;
            return label;
        }

        // Create base name labels - positioned outside the infield
        const baseLabels = new THREE.Group();
        baseLabels.add(createBaseLabel('Home Plate', new THREE.Vector3(homePos.x - 1.5, homePos.y, homePos.z - 1.5)));
        baseLabels.add(createBaseLabel('1st Base', new THREE.Vector3(firstPos.x - 1.5, firstPos.y, firstPos.z + 1.5)));
        baseLabels.add(createBaseLabel('Safety Base', new THREE.Vector3(safetyBasePos.x - 1.5, safetyBasePos.y, safetyBasePos.z + 1.5)));
        baseLabels.add(createBaseLabel('2nd Base', new THREE.Vector3(secondPos.x + 1.5, secondPos.y, secondPos.z + 1.5)));
        baseLabels.add(createBaseLabel('3rd Base', new THREE.Vector3(thirdPos.x + 1.5, thirdPos.y, thirdPos.z - 1.5)));
        
        scene.add(baseLabels);
        baseLabels.visible = true; // Set to true to show labels by default

        // Add toggle button functionality
        const dimensionToggle = document.getElementById('dimensionToggle');
        dimensionToggle.addEventListener('click', () => {
            // Toggle functionality kept but no labels will appear
            dimensionLabels.visible = !dimensionLabels.visible;
        });

        const baseNamesToggle = document.getElementById('baseNamesToggle');
        baseNamesToggle.addEventListener('click', () => {
            baseLabels.visible = !baseLabels.visible;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>