<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5Base Field - 3D Interactive Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .legend-item { display: flex; align-items: center; margin-bottom: 0.5rem; }
        .legend-color { width: 20px; height: 20px; margin-right: 0.5rem; border: 1px solid #333; }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div class="relative h-screen w-screen">
        <!-- 3D Canvas -->
        <div id="canvas-container" class="absolute inset-0"></div>
        
        <!-- UI Overlay -->
        <div class="absolute top-0 left-0 p-4 bg-black bg-opacity-50 rounded-br-lg">
            <h1 class="text-2xl font-bold mb-2">5Base Field</h1>
            <p class="text-sm mb-4">Interactive 3D Visualization</p>
            
            <!-- Controls -->
            <div class="mb-4">
                <button id="reset-camera" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded mr-2">
                    Reset View
                </button>
                <button id="toggle-legend" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded">
                    Toggle Legend
                </button>
            </div>
            
            <!-- Legend -->
            <div id="legend" class="text-xs bg-black bg-opacity-75 p-2 rounded">
                <h2 class="font-bold mb-2">Legend</h2>
                <div class="legend-item">
                    <div class="legend-color bg-gray-500"></div>
                    <span>Infield (13m × 13m)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-yellow-500"></div>
                    <span>Fair Territory (18m × 18m)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-white"></div>
                    <span>Foul Territory</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-red-500"></div>
                    <span>No-Hit Zone</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-yellow-300"></div>
                    <span>Batter's Box (3m × 3m)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-white border-2 border-black"></div>
                    <span>Bases (50cm × 50cm)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bg-orange-500"></div>
                    <span>Safe Area (1.5m)</span>
                </div>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="absolute bottom-0 right-0 p-4 bg-black bg-opacity-50 rounded-tl-lg text-xs">
            <p><strong>Controls:</strong> Left-click + drag to rotate | Right-click + drag to pan | Scroll to zoom</p>
        </div>
    </div>

    <!-- Import Three.js using ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        // Import Three.js and OrbitControls
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Main Three.js setup
        let scene, camera, renderer, controls;
        
        // Field dimensions in meters
        const INFIELD_SIZE = 13; // 13m square infield
        const FAIR_TERRITORY_SIZE = 18; // 18m square fair territory
        const BASE_SIZE = 0.5; // 50cm square bases
        const BATTERS_BOX_SIZE = 3; // 3m square batter's box
        const SAFE_AREA_WIDTH = 1.5; // 1.5m safe area at first base
        const NO_HIT_DISTANCE = 4.5; // 4.5m from home along foul lines
        const FENCE_HEIGHT = 1; // 1m high fences
        
        // Colors
        const INFIELD_COLOR = 0x808080; // Gray
        const FAIR_TERRITORY_COLOR = 0xFFD700; // Yellow
        const FOUL_TERRITORY_COLOR = 0xFFFFFF; // White
        const NO_HIT_ZONE_COLOR = 0xFF6347; // Tomato red
        const BATTERS_BOX_COLOR = 0xF0E68C; // Khaki
        const BASE_COLOR = 0xFFFFFF; // White
        const SAFE_AREA_COLOR = 0xFFA500; // Orange
        const FENCE_COLOR = 0x2F4F4F; // Dark slate gray
        const LINE_COLOR = 0x000000; // Black
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(
                60, // Field of view
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1, // Near clipping plane
                1000 // Far clipping plane
            );
            camera.position.set(0, 20, 20); // Position camera above and behind home plate
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2.1; // Limit to just above horizontal
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.6);
            scene.add(ambientLight);
            
            // Add directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Create the field
            createField();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Add button event listeners
            document.getElementById('reset-camera').addEventListener('click', resetCamera);
            document.getElementById('toggle-legend').addEventListener('click', toggleLegend);
            
            // Start animation loop
            animate();
        }
        
        // Create the baseball field
        function createField() {
            // Calculate positions
            // Center the field at the origin
            // Home plate is at the bottom-right corner of the infield
            const homePos = new THREE.Vector3(INFIELD_SIZE/2, 0, -INFIELD_SIZE/2);
            
            // First base is at the top-right corner of the infield
            const firstBaseCorner = new THREE.Vector3(INFIELD_SIZE/2, 0, INFIELD_SIZE/2);
            
            // Second base is at the top-left corner of the infield
            const secondBaseCorner = new THREE.Vector3(-INFIELD_SIZE/2, 0, INFIELD_SIZE/2);
            
            // Third base is at the bottom-left corner of the infield
            const thirdBaseCorner = new THREE.Vector3(-INFIELD_SIZE/2, 0, -INFIELD_SIZE/2);
            
            // Create ground plane
            const groundPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, // Lawn green
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                })
            );
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -0.02;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
            
            // Create fair territory (yellow area)
            const fairTerritory = new THREE.Mesh(
                new THREE.PlaneGeometry(FAIR_TERRITORY_SIZE, FAIR_TERRITORY_SIZE),
                new THREE.MeshStandardMaterial({ 
                    color: FAIR_TERRITORY_COLOR,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                })
            );
            fairTerritory.rotation.x = -Math.PI / 2;
            fairTerritory.position.set(0, 0, 0);
            fairTerritory.receiveShadow = true;
            scene.add(fairTerritory);
            
            // Create infield (gray area)
            const infield = new THREE.Mesh(
                new THREE.PlaneGeometry(INFIELD_SIZE, INFIELD_SIZE),
                new THREE.MeshStandardMaterial({ 
                    color: INFIELD_COLOR,
                    roughness: 0.9,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                })
            );
            infield.rotation.x = -Math.PI / 2;
            infield.position.set(0, 0.01, 0); // Slightly above fair territory
            infield.receiveShadow = true;
            scene.add(infield);
            
            // Create batter's box
            const battersBox = new THREE.Mesh(
                new THREE.PlaneGeometry(BATTERS_BOX_SIZE, BATTERS_BOX_SIZE),
                new THREE.MeshStandardMaterial({ 
                    color: BATTERS_BOX_COLOR,
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                })
            );
            battersBox.rotation.x = -Math.PI / 2;
            battersBox.position.set(
                homePos.x + BATTERS_BOX_SIZE/2, 
                0.015, // Slightly above the field
                homePos.z - BATTERS_BOX_SIZE/2
            );
            battersBox.receiveShadow = true;
            scene.add(battersBox);
            
            // Create no-hit zone (triangle from home plate into infield)
            function createNoHitZone() {
                // Create a triangular shape for the no-hit zone
                const noHitShape = new THREE.Shape();
                
                // Start at home plate
                noHitShape.moveTo(homePos.x, homePos.z);
                
                // Point at 4.5m INSIDE the field along the x-axis (toward third base)
                noHitShape.lineTo(homePos.x - NO_HIT_DISTANCE, homePos.z);
                
                // Point at 4.5m INSIDE the field along the z-axis (toward first base)
                noHitShape.lineTo(homePos.x, homePos.z + NO_HIT_DISTANCE);
                
                // Back to home plate
                noHitShape.lineTo(homePos.x, homePos.z);
                
                // Create geometry from the shape
                const noHitGeometry = new THREE.ShapeGeometry(noHitShape);
                
                // Create material with transparency
                const noHitMaterial = new THREE.MeshBasicMaterial({
                    color: NO_HIT_ZONE_COLOR,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                
                // Create mesh
                const noHitZone = new THREE.Mesh(noHitGeometry, noHitMaterial);
                noHitZone.rotation.x = Math.PI / 2;
                noHitZone.position.y = 0.02; // Slightly above the field
                
                return noHitZone;
            }

            // Create the no-hit zone line
            function createNoHitLine() {
                const points = [
                    new THREE.Vector3(homePos.x - NO_HIT_DISTANCE, 0.03, homePos.z), // Point INSIDE toward third base
                    new THREE.Vector3(homePos.x, 0.03, homePos.z + NO_HIT_DISTANCE)  // Point INSIDE toward first base
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xFF0000, linewidth: 3 });
                
                return new THREE.Line(geometry, material);
            }
            
            // Add the no-hit zone and line to the scene
            const noHitZone = createNoHitZone();
            scene.add(noHitZone);
            
            const noHitLine = createNoHitLine();
            scene.add(noHitLine);
            
            // Create bases with labels
            function createBase(position, type) {
                const baseGroup = new THREE.Group();
                
                // Create the base
                const baseGeometry = new THREE.BoxGeometry(BASE_SIZE, 0.05, BASE_SIZE);
                const baseMaterial = new THREE.MeshStandardMaterial({ 
                    color: BASE_COLOR,
                    roughness: 0.5,
                    metalness: 0.3
                });
                
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(0, 0.025, 0);
                base.castShadow = true;
                base.receiveShadow = true;
                baseGroup.add(base);
                
                // Add a border to the base
                const baseEdgeGeometry = new THREE.EdgesGeometry(baseGeometry);
                const baseEdges = new THREE.LineSegments(
                    baseEdgeGeometry,
                    new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
                );
                base.add(baseEdges);
                
                // Add a label to identify the base
                // Create a canvas for the texture
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                
                // Fill with white
                context.fillStyle = '#FFFFFF';
                context.fillRect(0, 0, 128, 128);
                
                // Add text
                context.fillStyle = '#000000';
                context.font = 'bold 80px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                let label = '';
                if (type === 'home') label = 'H';
                else if (type === 'first') label = '1';
                else if (type === 'safety') label = 'S';
                else if (type === 'second') label = '2';
                else if (type === 'third') label = '3';
                
                context.fillText(label, 64, 64);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                
                // Create a plane for the label
                const labelGeometry = new THREE.PlaneGeometry(BASE_SIZE * 0.8, BASE_SIZE * 0.8);
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
                
                const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                labelMesh.rotation.x = -Math.PI / 2;
                labelMesh.position.y = 0.051; // Just above the base
                baseGroup.add(labelMesh);
                
                // Position the entire group
                baseGroup.position.copy(position);
                
                return baseGroup;
            }
            
            // Home plate (with special shape for home)
            const homeBase = createBase(
                new THREE.Vector3(homePos.x, 0, homePos.z),
                'home'
            );
            scene.add(homeBase);
            
            // First base (in fair territory) - now at the top-right corner
            const firstBase = createBase(
                new THREE.Vector3(firstBaseCorner.x - BASE_SIZE/2, 0, firstBaseCorner.z - BASE_SIZE/2),
                'first'
            );
            scene.add(firstBase);
            
            // First base safety base (in foul territory)
            const safetyBase = createBase(
                new THREE.Vector3(firstBaseCorner.x - BASE_SIZE*1.5, 0, firstBaseCorner.z - BASE_SIZE/2),
                'safety'
            );
            // Change the color of the safety base to orange
            safetyBase.children[0].material = new THREE.MeshStandardMaterial({ 
                color: SAFE_AREA_COLOR,
                roughness: 0.5,
                metalness: 0.3
            });
            scene.add(safetyBase);
            
            // Safe area at first base
            const safeAreaGeometry = new THREE.PlaneGeometry(SAFE_AREA_WIDTH, BASE_SIZE);
            const safeAreaMaterial = new THREE.MeshBasicMaterial({
                color: SAFE_AREA_COLOR,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.4
            });
            
            const safeArea = new THREE.Mesh(safeAreaGeometry, safeAreaMaterial);
            safeArea.rotation.x = -Math.PI / 2;
            safeArea.position.set(
                firstBaseCorner.x - BASE_SIZE - SAFE_AREA_WIDTH/2, 
                0.015, 
                firstBaseCorner.z - BASE_SIZE/2
            );
            scene.add(safeArea);
            
            // Second base
            const secondBase = createBase(
                new THREE.Vector3(secondBaseCorner.x + BASE_SIZE/2, 0, secondBaseCorner.z - BASE_SIZE/2),
                'second'
            );
            scene.add(secondBase);
            
            // Third base - now at the bottom-left corner
            const thirdBase = createBase(
                new THREE.Vector3(thirdBaseCorner.x + BASE_SIZE/2, 0, thirdBaseCorner.z + BASE_SIZE/2),
                'third'
            );
            scene.add(thirdBase);
            
            // Create field lines
            // Infield lines
            function createLine(start, end, color = 0x000000, linewidth = 2) {
                const points = [
                    new THREE.Vector3(start.x, 0.03, start.z),
                    new THREE.Vector3(end.x, 0.03, end.z)
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color, linewidth });
                
                return new THREE.Line(geometry, material);
            }
            
            // Infield lines
            scene.add(createLine(homePos, firstBaseCorner));
            scene.add(createLine(firstBaseCorner, secondBaseCorner));
            scene.add(createLine(secondBaseCorner, thirdBaseCorner));
            scene.add(createLine(thirdBaseCorner, homePos));
            
            // Foul lines
            scene.add(createLine(
                homePos, 
                new THREE.Vector3(homePos.x, 0.03, homePos.z + FAIR_TERRITORY_SIZE),
                0xFF0000
            ));
            scene.add(createLine(
                homePos, 
                new THREE.Vector3(homePos.x - FAIR_TERRITORY_SIZE, 0.03, homePos.z),
                0xFF0000
            ));
            
            // Batter's box outline
            const boxPoints = [
                new THREE.Vector3(homePos.x, 0.03, homePos.z),
                new THREE.Vector3(homePos.x - BATTERS_BOX_SIZE, 0.03, homePos.z),
                new THREE.Vector3(homePos.x - BATTERS_BOX_SIZE, 0.03, homePos.z - BATTERS_BOX_SIZE),
                new THREE.Vector3(homePos.x, 0.03, homePos.z - BATTERS_BOX_SIZE),
                new THREE.Vector3(homePos.x, 0.03, homePos.z)
            ];
            
            const boxGeometry = new THREE.BufferGeometry().setFromPoints(boxPoints);
            const boxLine = new THREE.Line(
                boxGeometry,
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
            );
            scene.add(boxLine);
            
            // Create fences
            const fenceHeight = FENCE_HEIGHT;
            const fenceThickness = 0.05;
            
            // Left fence
            const leftFence = new THREE.Mesh(
                new THREE.BoxGeometry(fenceThickness, fenceHeight, FAIR_TERRITORY_SIZE),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            leftFence.position.set(-FAIR_TERRITORY_SIZE/2 - fenceThickness/2, fenceHeight/2, 0);
            leftFence.castShadow = true;
            scene.add(leftFence);
            
            // Top fence
            const topFence = new THREE.Mesh(
                new THREE.BoxGeometry(FAIR_TERRITORY_SIZE + fenceThickness*2, fenceHeight, fenceThickness),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            topFence.position.set(0, fenceHeight/2, FAIR_TERRITORY_SIZE/2 + fenceThickness/2);
            topFence.castShadow = true;
            scene.add(topFence);
            
            // Right fence
            const rightFence = new THREE.Mesh(
                new THREE.BoxGeometry(fenceThickness, fenceHeight, FAIR_TERRITORY_SIZE),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            rightFence.position.set(FAIR_TERRITORY_SIZE/2 + fenceThickness/2, fenceHeight/2, 0);
            rightFence.castShadow = true;
            scene.add(rightFence);
            
            // Bottom fence
            const bottomFence = new THREE.Mesh(
                new THREE.BoxGeometry(FAIR_TERRITORY_SIZE, fenceHeight, fenceThickness),
                new THREE.MeshStandardMaterial({ color: FENCE_COLOR })
            );
            bottomFence.position.set(0, fenceHeight/2, -FAIR_TERRITORY_SIZE/2 - fenceThickness/2);
            bottomFence.castShadow = true;
            scene.add(bottomFence);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Reset camera to initial position
        function resetCamera() {
            camera.position.set(0, 20, 20);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        // Toggle legend visibility
        function toggleLegend() {
            const legend = document.getElementById('legend');
            legend.style.display = legend.style.display === 'none' ? 'block' : 'none';
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize the scene when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
</html>